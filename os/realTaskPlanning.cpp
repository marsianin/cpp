#include <iostream>
#import <queue>

/**
В этом задании вам потребуется реализовать планировщик, использующий алгоритм Round Robin. Реализация планировщика состоит из нескольких функций:

void scheduler_setup(int timeslice) - вызывается перед началом работы, а timeslice - квант времени, который нужно использовать в некоторых единицах времени (что именно используется как единица времени, не существенно);
void new_thread(int thread_id) - оповещает планировщик о новом потоке с идентификатором thread_id;
void exit_thread() - оповещает планировщик о том, что текущий исполняемый на CPU поток завершился (соответственно, планировщик должен отдать CPU кому-то другому);
void block_thread() - оповещает планировщик, что текущий исполняемый поток был заблокирован (например, запросил IO операцию и должен отдать CPU);
void wake_thread(int thread_id) - оповещает, что поток с идентификатором thread_id был разблокирован (например, IO операция завершилась);
void timer_tick() - вызывается через равные интервалы времени, нотифицирует, что прошла одна единица времени;
int current_thread(void) - функция должна возвращать идентификатор потока, который сейчас должен выполняться на CPU, если такого потока нет, то нужно вернуть -1.

При выполнении задания каждый раз, когда поток выполняется на CPU и вызывается timer_tick, считайте, что поток отработал целую единицу времени на CPU.
 Т. е. даже если предыдущий поток добровольно освободил CPU (вызвав block_thread или exit_thread) и сразу после того, как CPU был отдан другому потоку,
 была вызвана функция timer_tick, то все равно считается, что второй поток отработал целую единицу времени на CPU.
 */

struct rr {
    int timeslice;
    int current_thread;
    int time;
    std::queue<int> id;
};

rr rrRun = {
    0,
    -1,
    0,
};

/**
 * Функция будет вызвана перед каждым тестом, если вы
 * используете глобальные и/или статические переменные
 * не полагайтесь на то, что они заполнены 0 - в них
 * могут храниться значения оставшиеся от предыдущих
 * тестов.
 *
 * timeslice - квант времени, который нужно использовать.
 * Поток смещается с CPU, если пока он занимал CPU функция
 * timer_tick была вызвана timeslice раз.
 **/
void scheduler_setup(int timeslice)
{
    rrRun.timeslice = timeslice;
    std::queue<int> empty;
    std::swap(rrRun.id, empty);
    rrRun.current_thread = -1;
    rrRun.time = 0;
}

/**
 * Функция вызывается, когда создается новый поток управления.
 * thread_id - идентификатор этого потока и гарантируется, что
 * никакие два потока не могут иметь одинаковый идентификатор.
 **/
void new_thread(int thread_id)
{
    if (rrRun.current_thread == -1) {
        rrRun.current_thread = thread_id;
        rrRun.time = 0;
    } else {
        rrRun.id.push(thread_id);
    }
}

/**
 * Функция вызывается, когда поток, исполняющийся на CPU,
 * завершается. Завершится может только поток, который сейчас
 * исполняется, поэтому thread_id не передается. CPU должен
 * быть отдан другому потоку, если есть активный
 * (незаблокированный и незавершившийся) поток.
 **/
void exit_thread()
{
    rrRun.time = 0;
    if (rrRun.id.size() == 0) {
        rrRun.current_thread = -1;
    } else {
        rrRun.current_thread = rrRun.id.front();
        rrRun.id.pop();
    }
}

/**
 * Функция вызывается, когда поток, исполняющийся на CPU,
 * блокируется. Заблокироваться может только поток, который
 * сейчас исполняется, поэтому thread_id не передается. CPU
 * должен быть отдан другому активному потоку, если таковой
 * имеется.
 **/
void block_thread()
{
    exit_thread();
}

/**
 * Функция вызывается, когда один из заблокированных потоков
 * разблокируется. Гарантируется, что thread_id - идентификатор
 * ранее заблокированного потока.
 **/
void wake_thread(int thread_id)
{
    new_thread(thread_id);
}

/**
 * Ваш таймер. Вызывается каждый раз, когда проходит единица
 * времени.
 **/
void timer_tick()
{
    if (rrRun.current_thread == -1) {
        return;
    }
    rrRun.time++;
    if (rrRun.time == rrRun.timeslice) {
        rrRun.id.push(rrRun.current_thread);
        rrRun.current_thread = rrRun.id.front();
        rrRun.id.pop();
        rrRun.time = 0;
    }
}

/**
 * Функция должна возвращать идентификатор потока, который в
 * данный момент занимает CPU, или -1 если такого потока нет.
 * Единственная ситуация, когда функция может вернуть -1, это
 * когда нет ни одного активного потока (все созданные потоки
 * либо уже завершены, либо заблокированы).
 **/
int current_thread()
{
    return rrRun.current_thread;
}